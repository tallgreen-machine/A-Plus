import pandas as pd
import pandas_ta as ta
from core.event_system import EventBus, MarketEvent, SignalEvent
from utils.logger import log

# Import the strategy classes
from strategies.htf_sweep import HTFSweep
from strategies.volume_breakout import VolumeBreakout
from strategies.divergence_capitulation import DivergenceCapitulation

class SignalLibrary:
    def __init__(self, event_bus: EventBus, symbols: list):
        self.event_bus = event_bus
        self.symbols = symbols
        self.latest_data = {symbol: {} for symbol in symbols}  # {symbol: {tf: ohlcv_df}}

        # Register the strategies to be used
        self.strategies = [
            HTFSweep,
            VolumeBreakout,
            DivergenceCapitulation
        ]
        log.info(f"SignalLibrary initialized with {len(self.strategies)} strategies.")
        self.event_bus.subscribe(MarketEvent, self.on_market_event)

    def on_market_event(self, event: MarketEvent):
        """
        Handles new market data, updates the internal state, and checks for trading signals.
        """
        symbol = event.symbol
        tf = event.timeframe
        self.latest_data[symbol][tf] = event.data
        log.debug(f"Market data updated for {symbol} on timeframe {tf}.")

        # We have new data, let's see if it generates a signal
        self.check_for_signals(symbol)

    def check_for_signals(self, symbol: str):
        """
        Orchestrates the checking of all available trading strategies for a given symbol.
        """
        log.debug(f"Checking for signals on {symbol}...")
        
        for strategy_class in self.strategies:
            # Pass all available data for the symbol to the strategy
            strategy_instance = strategy_class(symbol, self.latest_data[symbol])
            signal = strategy_instance.check_signal()
            
            if signal:
                log.info(f"Signal generated by {strategy_class.__name__} for {symbol}: {signal.signal_type} {signal.symbol} at {signal.price}")
                self.event_bus.publish(signal)
                # Stop after the first signal to avoid conflicting signals on the same candle
                break

    def get_latest_data(self, symbol: str, timeframe: str) -> pd.DataFrame:
        """
        Provides access to the most recent OHLCV data for a given symbol and timeframe.
        """
        return self.latest_data.get(symbol, {}).get(timeframe, pd.DataFrame())

