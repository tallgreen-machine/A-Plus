# core/event_system.py

from dataclasses import dataclass
from typing import Callable, Dict, List, Type
import pandas as pd

# 1. Event Data Classes (as specified in section 2.2 of the trading_strategy.rtf)

@dataclass
class Event:
    """Base class for all events, providing a common interface."""
    pass

@dataclass
class MarketEvent(Event):
    """
    Generated by the DataHandler when new market data (e.g., a closed candle) is available.
    """
    symbol: str
    timeframe: str
    data: 'pd.DataFrame'

@dataclass
class SignalEvent(Event):
    """
    Generated by the SignalLibrary when a trading opportunity is identified.
    """
    symbol: str
    signal_type: str  # 'BUY' or 'SELL'
    strategy_id: str # e.g., 'VOLUME_BREAKOUT_BULLISH'
    price: float
    confidence: float
    price_target: float
    stop_loss: float

@dataclass
class OrderEvent(Event):
    """
    Generated by the ExecutionCore to instruct the brokerage interface to place an order.
    """
    symbol: str
    order_type: str  # 'MARKET' or 'LIMIT'
    quantity: float
    direction: str  # 'BUY' or 'SELL'
    wallet_id: str

@dataclass
class FillEvent(Event):
    """
    Generated by the ExecutionCore upon confirming an order execution (a trade).
    Contains the details of the transaction.
    """
    symbol: str
    direction: str      # 'BUY' or 'SELL'
    quantity: float
    price: float
    fill_cost: float
    commission: float
    wallet_id: str


# 2. Event Bus (as specified in section 2.1 of the trading_strategy.rtf)

Handler = Callable[[Event], None]

class EventBus:
    """
    A simple publish/subscribe event bus.
    This facilitates decoupled communication between the system's core modules,
    allowing a one-to-many broadcast model.
    """
    def __init__(self):
        self._handlers: Dict[Type[Event], List[Handler]] = {}

    def subscribe(self, event_type: Type[Event], handler: Handler):
        """Register a handler for a specific event type."""
        if event_type not in self._handlers:
            self._handlers[event_type] = []
        self._handlers[event_type].append(handler)
        print(f"Handler '{getattr(handler, '__name__', 'anonymous')}' subscribed to '{event_type.__name__}'")

    def publish(self, event: Event):
        """
        Publish an event to all subscribed handlers.
        The event is broadcast to all handlers registered for its specific type.
        """
        event_type = type(event)
        if event_type in self._handlers:
            for handler in self._handlers[event_type]:
                try:
                    # Call the handler with the event
                    handler(event)
                except Exception as e:
                    print(f"Error in handler '{getattr(handler, '__name__', 'anonymous')}' for event {event}: {e}")
        else:
            # This is not an error, just means no module is currently interested in this event.
            # print(f"No handlers for event type: {event_type.__name__}")
            pass
